# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE,
fig.width = 9, fig.height = 6, dev = "ragg_png")
#knitr::opts_knit$set(root.dir = 'C:/Users/kramer/PopDynIZW Dropbox/Steph Kramer')
#or on GUI: knit -> knit directory -> project directory
# Chunk 3
# "comment"
1 + 1
# store calculus etc in an object
what_is_one_plus_one <- 1 + 1
# display result
what_is_one_plus_one
# assign character
what_is_one_plus_one <- 'two'
# Chunk 4
# Find the errors - try these lines
#What_is_one_plus_one
#what_is_one_plusone
#what_is_one_plus_two
# Chunk 6
what_is_one_plus_one <- 1 + 1
1 + what_is_one_plus_one
# Chunk 10
#- Use the command 'c' - it combines values into a vector or list
vector_of_numbers <- c(22, 65, 101, 86, 110)
# e.g. wingspan of dragonflies in mm
vector_of_numbers
mean(x = vector_of_numbers)
# Chunk 11
mean(x = vector_of_numbers) # n.b. better use argument names (x= ...)
# Chunk 13
# analogously: more useful functions/ commands:
sqrt(x = vector_of_numbers) # exp(), sin(), log()...
sum(x = vector_of_numbers)
# Chunk 14
# Assign the assigned values
wsp_drfly <- vector_of_numbers #wingspan of dragonflies
wsp_drfly
mean(x = wsp_drfly)
# Adding data, e.g. new measurements
wsp_drfly2 <- c(vector_of_numbers, wsp_drfly, 69 ,73)
wsp_drfly2
# Chunk 15
table(wsp_drfly2) # returns the counts
sort(x = wsp_drfly2)
min(wsp_drfly2) #analogous max, var, sd, range, median
# Chunk 16
unique(x = wsp_drfly2) # n.b. - does not sort vector
# n.b. - if you want to: sort(unique(x = wsp_drfly2)) # mind: you can nest functions!
length(x = wsp_drfly2)
summary(object = wsp_drfly2)
# Chunk 17
?Arithmetic
wsp_drfly2 * 2
wsp_drfly2 * 10 - 100
# Chunk 18
?base::Logic
wsp_drfly2 > 10 # >=, <, <=, &, | , !=, ==
wsp_drfly2 == 75 # n.b. difference to = or <- !!!!
# Chunk 19
# wingspan of butterflies in mm
wsp_butfly2 <- c(12, 48, 79, 135, 189, 88, 15, 63, 21, 81, 148, 50)
data_length <- length(x = wsp_butfly2) #12
wsp <- c(wsp_drfly2, wsp_butfly2)
insect_type <- factor(x = c(rep('dragonfly', data_length),
rep('butterfly', data_length)))
# n.b. correct position of parentheses when functions nested
insect_type
# Chunk 20
wsp_table <- data.frame(wingspan = wsp, insect = insect_type)
head(x = wsp_table) # head() returns first 6 rows # tail()
wsp_table
## Retrieving data from df
str(object = wsp_table)
wsp
wsp_table$wingspan # access data with dollar sign
# Chunk 21
vector_of_numbers[3]
# vector_of_numbers[c(1, 3:5)]
# why c(...)? Because the comma is another dimension.
# dimension in R: [row, column]
# Not run: vector_of_numbers[1, 3:5] #error
# Chunk 22
wsp_table[2, 2] # == wsp_table$insect[2] #!
wsp_table[2, 1] # == wsp_table$wingspan[2] #!
wsp_table[2, ]
# Chunk 23
wsp_table[, 2]
# Chunk 25
wsp_table[c(2:5), 2]
# Chunk 26
mean(x = wsp_table$wingspan[wsp_table$insect == 'dragonfly']) # == !
#- more elegant: function 'tapply'
tapply(X = wsp_table$wingspan, INDEX = wsp_table$insect, FUN = mean)
# Chunk 27
wsp_sub <- subset(x = wsp_table, subset = wsp_table$wingspan <= 65)
nrow(wsp_sub) # try also: dim(wsp_sub),dim(wsp_sub)[1]
wsp_sub
# Chunk 28
wsp_tmp <- which(x = wsp_table$wingspan <= 65)
wsp_tmp
wsp_which <- wsp_table[wsp_tmp,]
wsp_which
# Chunk 29
x <- wsp_which
x
x2 <- x[-c(1, 3), ] # remove rows
x2
# Chunk 30
x22 <- x$wingspan # removes (actually keeps) columns
x22
# Chunk 31
x3 <- rbind(x2, wsp_table)
x3[1:10,] # n.b. new row names 41, 91 !
# Chunk 32
x4 <- cbind(vector_of_numbers[1:3], vector_of_numbers[3:5])
x4
colnames(x4) <- c('col1', 'col2')
rownames(x4) <- c('A', 'B', 'C')
x4
# Chunk 33
wsp_list <- list(dragonfly = wsp_drfly2, butterfly = wsp_butfly2)
str(wsp_list)
wsp_list$dragonfly # == wsp_list[['dragonfly']]
lapply(X = wsp_list, FUN = mean) # OR: mean(wsp_list$dragonfly)
# Chunk 34
wsp_matrix <- matrix(data = c(wsp_drfly2, wsp_butfly2), nrow = 2)
wsp_matrix
# Does this format ring a bell??
rownames(x = wsp_matrix) <- c('dragonfly', 'butterfly')
wsp_matrix[, 1]
wsp_matrix['dragonfly', ] # == wsp_matrix[1, ]
# Chunk 35
wsp_matrix <- matrix(data = c(wsp_drfly2, wsp_butfly2), ncol = 2)
wsp_matrix
#head(wsp_matrix)
#str(wsp_matrix)
wsp_matrix[, 1]
colnames(x = wsp_matrix) <- c('dragonfly', 'butterfly')
#wsp_matrix$dragonfly
wsp_matrix[, 'dragonfly'] # == wsp_matrix[, 1]
# Chunk 36
#wsp_matrix <- matrix(c(wsp_drfly2,wsp_butfly2), ncol=2)
#colnames(wsp_matrix) <- c('dragonfly','butterfly')
mean(x = wsp_matrix[, 1])
apply(X = wsp_matrix, MARGIN = 2, FUN = mean)
# Chunk 37
wsp_fly2 <- c(1, 5, 4, 11, 8, 2, NA, 4, 2, 9, 8, NA)
mean(x = wsp_fly2)
# type ?mean
# How to deal with missing data?
mean(x = wsp_fly2, na.rm = TRUE)
# Chunk 38
wsp_l <- list(dragonfly = wsp_drfly2, butterfly = wsp_butfly2, fly = wsp_fly2)
lapply(X = wsp_l, FUN = mean)
lapply(X = wsp_l, FUN = mean, na.rm = TRUE)
# Chunk 39
#TRY
# class(wsp_table) #class(wsp_matrix) #class(wsp_list)
# on vectors: #class(insect_type) # class(wsp_l$dragonfly)
# on skalars: #class(what_is_one_plus_one)
# Chunk 40
getwd() # to change use setwd(), e.g. setwd('../Output')
write.csv(x = wsp_table, file = "wsp.csv", row.names = FALSE)
wsp <- read.csv(file = "wsp.csv", header = T)
head(x = wsp)
# Chunk 41
# this does not work because you need to specify numeric values,
# column 'insect' is of type character
# plot(x = wsp)
# solution
plot(x = wsp$wingspan)
# Chunk 42
color_for_insect_type <- ifelse(test = wsp$insect == 'dragonfly', yes = 'red', no = 'blue')
# color_for_insect_type
plot(x = wsp$wingspan, col= color_for_insect_type)
# Chunk 43
# now have a look at
?base::plot # and
?par # of how to make the plots more pretty and how to set graphical parameters
plot(x = wsp$wingspan, col = color_for_insect_type, pch = 3,
xlab = "unsorted values", ylab = "wsp [mm]", cex = 3,
cex.lab = 1.2, cex.axis = 0.5, las = 2,
col.axis = "blue")
# Chunk 44
?abline
plot(x = wsp$wingspan, col = color_for_insect_type)
abline(v = 12.5, lty = "dashed", col = "red")
#lty = line type
abline(h = 75, lty = "dotted")
# Chunk 45
plot(x = wsp$wingspan, col = color_for_insect_type,pch = 16, cex = 3)
arrows(x0 = 5, y0 = 125, x1 = 5, y1 = 82, col = "purple")
arrows(x0 = 15, y0 =  70, x1 = 17, y1 =  75, col = "black", lwd = 3) #lwd=line width
text(x = 3, y = 70, labels = "DRAGONFLY",cex=0.8)
# Chunk 46
#First, create new data set called " mydata" with new column "wind_speed":
wind_speed <- rep(x = 50:70, length.out = nrow(wsp))
mydata <- cbind(wsp, wind_speed)
head(x = mydata)
# Chunk 47
par(mfrow = c(1, 2))
boxplot(formula = mydata$wingspan ~ mydata$wind_speed)
hist(x = mydata$wingspan, main = '')
# Chunk 48
par(mfrow = c(1,2))
hist(x = mydata$wingspan, breaks = 2, main = '')
hist(x = mydata$wingspan,
breaks = seq(min(mydata$wingspan),
max(mydata$wingspan),
by = 3),
freq = FALSE, col = 'lightgrey', main = '')
# Chunk 49
my_h <- hist(x = mydata$wingspan,
breaks = seq(min(mydata$wingspan),
max(mydata$wingspan), by = 3), plot = FALSE)
my_h
# Chunk 50
my_bp <- table(mydata$wingspan)
my_bp # note the difference to histograms ($counts)!
barplot(my_bp) # WHY is there a maximum of 3 counts in the histogram and 2 in the barplot?
# Chunk 51
coplot(formula = mydata$wingspan ~ mydata$wind_speed | mydata$insect, pch = 16)
# Chunk 52
#mar = margin of figure in blue, oma = outer margin in green
par(mfrow = c(1, 2), mar = c(5, 4, 1, 1), oma = c(1.5, 2, 1, 1))
plot(x = mydata$wingspan, col = color_for_insect_type, pch = 16, cex = 3)
boxplot(formula = mydata$wingspan ~ mydata$insect)
box(which = 'plot', col = 'red')
box(which = 'figure', col = 'blue', lty = 'dashed')
box(which = 'outer', col = 'green' , lwd = 5)
# Chunk 54
# install.packages('ggplot2')
library(ggplot2) # don't forget to install the package before
ggplot(data = mydata) # nothing happens but a grey panel appearing with the extent of the data
# Chunk 55
ggplot(data = mydata, mapping = aes(x = wind_speed, y = wingspan)) +
# everything related to the data should be in the aesthetics (aes)
geom_point()
# Chunk 56
ggplot(mydata, aes(wind_speed, wingspan)) + # data, mapping(x, y)
geom_point()
# Chunk 57
ggplot(mydata, aes(x = wind_speed, y = wingspan)) +
geom_point(
shape = 17,
size = 5,
col = 'gray40',
alpha = 0.5
)
# Chunk 58
myggplot1 <-
ggplot(mydata, aes(x = wind_speed, y = wingspan)) +
geom_point(
shape = 17,
size = 5,
col = "red",
alpha = 0.4 #makes shapes transparent
)
#to plot, call the object
myggplot1
# Chunk 59
myggplot1 +
labs(x = 'Wind Speed', y = 'Wing span [mm]') +
theme_dark()
# Chunk 60
theme_set(theme_light(base_size = 15))
# Chunk 61
myggplot1 +
facet_grid(. ~ insect) +
labs(x = 'Wind Speed', y = 'Wing span [mm]')
# Chunk 62
ggplot(mydata, aes(x = insect, y = wingspan, color = wind_speed)) +
geom_boxplot() +
geom_jitter(width = .1, alpha = .5,size=5) +
labs(x = "Insect taxon", y = "Wing span [mm]")
# Chunk 63
# mind where the color argument is set now: because different colours
# should be used for the violin plot and the jitter dots.
ggplot(mydata, aes(x = insect, y = wingspan)) +
geom_violin(fill = "gray80", size = 1, alpha = .5) +
geom_jitter(color = 'grey50',width = .1, alpha = .5, size=10) +
labs(x = "Insect taxon", y = "Wing span [mm]")
# Chunk 64
library(ggridges) # install package first if needed
ggplot(mydata, aes(x = wingspan, y = factor(insect))) +
geom_density_ridges(fill = "gray90") +
labs(x = "Wing span [mm]", y = "Taxon") +
theme_light()
# Chunk 65
library(rphylopic) # install first
library(patchwork) # for arranging the plots
#import phylopic (go to phylopic.org -> browse image -> click on image to get url)
drfly <- image_data("2894776f-a2cf-4475-b13d-6d8ea1607ea4", size = 128)[[1]]
bufly <- image_data("ef0f4ab5-9714-45dc-8760-57e9080f941e", size = 128)[[1]]
p1 <- ggplot(mydata, aes(x = wind_speed, y = wingspan)) +
geom_point() +
add_phylopic(img = drfly) +
labs(x = 'Wind Speed', y = 'Wing span [mm]', size = 15) +
theme_light()
###
p2 <- ggplot(mydata, aes(x = wind_speed, y =wingspan)) +
geom_point(color = rgb(0,0,0,0)) +
theme_light()
sub_drag <- subset(mydata, insect == 'dragonfly')
sub_butt <- subset(mydata, insect == 'butterfly')
for (i in 1:nrow(sub_drag)) {
p2 <- p2 + add_phylopic(drfly, 1,
sub_drag$wind_speed[i],
sub_drag$wingspan[i],10,'blue')}
for (j in 1:nrow(sub_butt)) {
p2 <- p2 + add_phylopic(bufly, 1,
sub_butt$wind_speed[j],
sub_butt$wingspan[j],10,'red')}
###
p3 <- ggplot(mydata, aes(x = wingspan, y = factor(insect))) +
geom_density_ridges(fill = "gray90") +
add_phylopic(img = bufly, alpha=1,
x = 50, y = 1.5, ysize = 20) +
add_phylopic(img = drfly, alpha = 1,
x = 80, y = 3, ysize = 25)  +
labs(x = "Wing span [mm]", y = "Taxon") +
theme_light()
### panel
p3 / (p1 + p2) + plot_annotation(tag_levels = "A", tag_suffix = ")")
# Chunk 66
myridgeplot <- ggplot(mydata, aes(x = wingspan, y = factor(insect))) +
geom_density_ridges(fill = "gray90") +
labs(x = "Wing span [mm]", y = "Taxon") +
theme_light()
myfilename <- "ridges.pdf"
ggsave(myridgeplot, file = myfilename, width = 4, height = 4)
# also works without the plot object named explicitely because ggsave() always refers to last plot by default
# ggsave(file = myfilename, width = 4, height = 4)
# Chunk 67
seq_data  <- seq(from = 1, to = 100, by = 1)     # create the x-axis, i.e. 100 time steps
norm_data <- rnorm(n = 100, mean = 0, sd = 1.96) # create normally distributed data (noise) around mean
#simulate trend = y-axis: intercept  + (slope * variable) +  error
trend_data <-  5  + (0.1 * seq_data) + norm_data #e.g. temperature
par(mfrow = c(1,1))
plot(x = seq_data, y = trend_data, pch = 15, col = 'grey', ylim = c(0,20))
lines(x = trend_data, pch = 17, col = 'blue')
abline(a = 5, b = 0.1, col = 'red', lwd=0.5)
# Chunk 68
my.lm <- lm(formula = trend_data ~ seq_data)
summary(object = my.lm)
# Chunk 69
par(mfrow=c(1,1))
plot(x = seq_data, y = trend_data, pch = 15, col = 'grey', ylim = c(0,20))
lines(x = trend_data, pch = 17, col = 'blue')
abline(a = 5, b = 0.1, col = 'red', lwd=0.5) # 'reality'
abline(my.lm, col = 'black') # fitted model
# Chunk 70
#- for repetitive operations
#- *i* is used as counter variable that is incremented
for(i in 1:4)
{ #begin
print(x = i)
if (i == 4) print (x = 'end of lop')
} # end
?'for'
#other useful control flow constructs are: *while*, *repeat*, *if*
# Chunk 71
f_logit <- function(var1) {-8.13 + (12.15 * var1)}   # linear model
f_prob  <- function(var2) {1/ (1 + exp(x = -var2))} # inverse logit
# perc_for = e.g. percentage of forest in a sampling plot/ area between 0 and 1 (=100%)
perc_for <- seq(from = 0, to = 1 ,by = 0.05)
the_logit  <- f_logit(var1 =  perc_for)
pres_prob  <- f_prob(var2 = the_logit) # here values of f_logit() are inserted into f_prob()
#pres_prob
plot(x = perc_for,y = pres_prob, type = 'l',
xlab = 'percentage of forest', ylab = 'prob of presence')
# Chunk 72
# define functions at the beginning of a script:
f_logit <- function(var1, intcpt, slp) {intcpt + (slp * var1)}
f_prob  <- function(var2) {1 / (1 + exp(x = -var2))} #inverse logit
# simulate trend, i.e. the 'real' relationship:
seq_data  <- seq(from = 0, to = 1, by=0.01) # e.g. forest percentage
trend_data <- pbinom(q = 1:length(seq_data), size = length(seq_data), prob = 0.6)
plot(x = seq_data, y = trend_data, pch = 15)
# Chunk 73
# install.packages("purrr") # in case the package is not installed
set.seed(500) # ignore this line
trend_data_binom <- purrr::rbernoulli(length(seq_data),trend_data)
plot(x = seq_data, y = trend_data, pch = 15, col = 'grey')
points(x = seq_data, y = trend_data_binom, pch = '|')
# Chunk 74
my.glm <- glm(formula = trend_data_binom ~ seq_data, family = 'binomial', na.action = na.omit)
summary(my.glm)
# store the output; access my.lm object via:
#str(my.lm)
myintercept <- my.glm$coefficients[[1]]
myslope     <- my.glm$coefficients[[2]]
# predict it for a certain range of variable values (seq_data)...
mylogit   <- f_logit(var1 = seq_data, intcpt = myintercept, slp = myslope)
pres_prob <- f_prob(var2 = mylogit)
# strictly linear relationship on the logit scale:
plot(x = seq_data, y = mylogit, type = 'l', lwd = 2)
# Chunk 75
# on the response / inverse logit scale:
plot(x = seq_data, y = pres_prob, type = 'l', lwd = 2)
# Chunk 76
plot(x = seq_data, y = pres_prob, type = 'l', lwd = 2) # fitted model
lines(x = seq_data, y = trend_data, pch = 15, col = 'grey') # 'true' distribution
points(x = seq_data, y = trend_data_binom, pch = '|') #field sampling based on 'true' distribution
# Chunk 77
myvalue <- 0.5
mylogit_s   <- f_logit(var1 = myvalue, intcpt = myintercept, slp = myslope)
(pres_prob_s <- f_prob(var2 = mylogit_s))
plot(x = seq_data, y = pres_prob, type = 'l', lwd = 2) # fitted model
abline(v = myvalue, lty = 2, lwd = 0.1)
abline(h = pres_prob_s, lty = 2, lwd = 0.1)
# Chunk 78: sessionInfo
Sys.time()
sessionInfo()
# Chunk 79: session-info
sessionInfo()
inv.logit(-0.326)
install.packages("boot")
inv.logit(-0.326)
library(boot)
inv.logit(-0.326)
inv.logit(-0.326-0.293)
inv.logit(-0.326+0.293)
