here::dr_here() # because here() alone interferes with the package `purrr` if that is loaded
root_wd <- here::here() # the root folder is automatically set
root_wd
## today, we start with Borneo
#dbor_wd     <- paste0(root_wd, "/", "data/data_borneo") #- the old way
dbor_wd     <- here("data","data_borneo") #- note the nested folder structure
#  maps_wd   <- here("data","data_borneo","geo_raster_current_asc")  ##  same as:
maps_wd   <- paste0(dbor_wd, "/geo_raster_current_asc") #- mind difference paste0() and paste()
vecs_wd   <- paste0(dbor_wd, "/geo_vector")
anim_wd   <-  paste(dbor_wd, "/animal_data", sep = '')   #- paste() needs a separator sign
#output_wd <- paste0(dirname(root_wd), "/", "output") #- the old way
output_wd <- here("output")
if (!dir.exists(output_wd)) {dir.create(output_wd)} #- create only if directory does NOT! exist
filenames <- list.files(path = maps_wd)
head(x = filenames)
## read the ascii file as raster format
ras_bio_asc_01 <- rast(x = paste0(maps_wd, "/bio_asc_01.asc")) ## `raster()` with {raster}
## or use here:
ras_bio_asc_01 <- rast(x = here("data", "data_borneo","geo_raster_current_asc", "bio_asc_01.asc"))
Bor_mat <- ras_bio_asc_01  ## easy copying of whole maps; mat stands for mean annual temp
ras_bio_asc_01
## ras_bio_asc_24 = DEM = digital elevation model
ras_bio_asc_24 <- rast(x = paste0(maps_wd, "/bio_asc_24.asc")) ## `raster()` in {raster}
crs(ras_bio_asc_24)
crs(ras_bio_asc_24) <- crs(ras_bio_asc_01)
## same as:
# crs(ras_bio_asc_24) <- crs("+proj=longlat +datum=WGS84")
## base plot
plot(x = ras_bio_asc_01)
ext(x = ras_bio_asc_01) ## `extent()` with {raster}
clip_extent <- ext(117.2, 117.45, 5.4, 5.5)
ras_bio_asc_01_cr <- crop(x = ras_bio_asc_01, y = clip_extent)
plot(ras_bio_asc_01_cr, col = viridis::inferno(10))
ext(ras_bio_asc_01_cr)
xmin(ras_bio_asc_01_cr) ## or: xmin(ext(ras_bio_asc_01_cr))
ncol(ras_bio_asc_01_cr)
head(ras_bio_asc_01_cr)
crs(ras_bio_asc_01_cr) ## != CRS(ras_bio_asc_01_cr)
## crs = coordinate reference system defined
## CRS creates projection and takes args for crs!
## e.g.
wgs84_crs_args <- CRS("+proj=longlat +datum=WGS84")
# wgs84_crs_args  ## please check
slope <- terrain(x = ras_bio_asc_24, v = "slope", unit = "radians", neighbors = 8) ## arg `v` called `opt` in {raster}
aspect <- terrain(x = ras_bio_asc_24, v = "aspect", unit = "radians", neighbors = 8) ## arg `v` called `opt` in {raster}
Bor_hs <- shade(slope, aspect, angle = 45, direction = 270) ## `hillShade()` in {raster}
## {raster} equivalent:
#slope <- terrain(x = ras_bio_asc_24, opt = "slope", unit = "radians", neighbors = 8)
#aspect <- terrain(x = ras_bio_asc_24, opt = "aspect", unit = "radians", neighbors = 8)
#Bor_hs <- hillShade(slope, aspect, angle = 45, direction = 270)
plot(Bor_hs, col = grey(0:100/100), legend = FALSE)
Bor_dem_moll <- terra::project(ras_bio_asc_01_cr, "+proj=moll +lat_0=65 +lon_0=10")
## `projectRaster()` in {raster}
persp(Bor_dem_moll, xlab = "Easting", ylab = "Northing",
zlab = "elevation", main = "Elevation model of Borneo",
r = 1, d = 5.5, expand = 0.1, ticktype = "detailed")
# gives names and full path of file
files.full <- list.files(path = maps_wd, pattern = '.asc$', full.names = TRUE)
# files.full # check also
files.full[1:3]
# names only
files.rel <- list.files(path = maps_wd, pattern = '.asc$', full.names = FALSE)
files.rel[1:3]
predictors <- rast(x = files.full[c(1, 2, 4, 6)]) ## `stack()` in {raster}
crs(predictors)
crs( predictors) <- "+proj=longlat +datum=WGS84"
predictors[[1]] # this is a list! Address single layers with [[ ]]
# with {terra} you can also use $ syntax:
predictors$bio_asc_01
rasterVis::bwplot(x = predictors[[c(1, 3)]]) # bwplot(predictors)
## n.b. double [[ ]] because stack is a list of spatial rasters
## first omit NA values (which represent the ocean around Borneo)
raster_df <- na.omit(data.frame(values(predictors[[c(1,3)]])))
raster_names <- names(raster_df)
raster_ct    <- dim(raster_df)[1]
df2 <- data.frame(val = c(raster_df[,names(raster_df)[1]],
raster_df[,names(raster_df)[3]]))
raster_df
head(raster_df)
df2 <- data.frame(val = c(raster_df[,names(raster_df)[1]],
raster_df[,names(raster_df)[2]]))
df2$grp <- rep(raster_names , each = raster_ct)
head(df2)
## take a random subsample of the data to not crash your PC when plotting:
a <- sample(x = nrow(df2), size = 1000, replace = FALSE)
df3 <- df2[a,]
## a violin-box plot combination with raw data strips
p <- ggplot(data = df3, aes(x = grp, y = val)) +
geom_violin(scale = "width", fill = "grey85", color = "#3366FF", bw = 20) +
geom_boxplot(width = 0.15, size = 0.8, outlier.color = NA) + ## remove outliers
geom_jitter(height = 0, width = 0.05, alpha = 0.2, size = 1.5, color = 'blue')
p
#- Extract information from all rasters in one command
# cellStats(predictors, 'mean')
round(x = global(x = predictors, stat = 'mean', na.rm = TRUE), digits = 2)
## `global()` -> `cellStats()` in {raster}
writeRaster(x = hillsh,
filename = paste0(output_wd,"/hillshade.asc"),
# or use here: here("output", "hillshade.asc")
overwrite = TRUE,
NAflag = -9999)
new_ras <- ras_bio_asc_01 + ras_bio_asc_24 + 100
# collapse 20*20 cells into 1 using function 'mean':
ras_bio_asc_01_agg <- aggregate(x = ras_bio_asc_01, fact = 20, fun = mean)
output_wd
writeRaster(x = hillsh,
filename = paste0(output_wd,"/hillshade.asc"),
# or use here: here("output", "hillshade.asc")
overwrite = TRUE,
NAflag = -9999)
?writeRaster
writeRaster(x = hillsh,
filename = paste0(output_wd,"/hillshade.asc"),
# or use here: here("output", "hillshade.asc")
overwrite = TRUE,
NAflag = NA)
hillsh
Bor_hs
writeRaster(x = Bor_hs,
filename = paste0(output_wd,"/hillshade.asc"),
# or use here: here("output", "hillshade.asc")
overwrite = TRUE,
NAflag = -9999)
# convert ras_bio_asc_01 to degree Celsius units (divide by 10)
range(values(ras_bio_asc_01), na.rm = TRUE)
mean.t.c <- ras_bio_asc_01 / 10
range(values(mean.t.c), na.rm = TRUE)
# find areas with mean annual temp >= 25 deg C
mean.t.c.25 <- mean.t.c >= 25
cells <- cellFromRowCol(object = ras_bio_asc_01_cr, row = 5, col = 1:3)
cells    ## returns cell ID number, the index / rownumber! Not the value!
extract(x = ras_bio_asc_01_cr, y = cells) ## returns cell values!
plot(x = ras_bio_asc_01_cr)
## to plot the points on top, insert the 'cells' index into
## the data frame of the coordinates of the RasterLayer object ras_bio_asc_01_cr
points(x = crds(ras_bio_asc_01_cr)[cells,], col = "blue")
center_x = floor(nrow(predictors) / 2) ## learn about the functions round(),
center_y = floor(ncol(predictors) / 2) ##                 ceiling(), floor()
center_x; center_y
stack_cells <- cellFromRowCol(
object = ras_bio_asc_01,
row = center_x:(center_x + 5),
col = center_y:(center_y + 5)
)
head(stack_cells) ## mind: these are index numbers! Not cell values!
pred_dat <- extract(predictors, stack_cells)
head(pred_dat)
## combine in one table
mastertable <- data.frame(stack_cells, pred_dat)
mastertable
## get the coordinates; cells was the object containing the index (i.e. the cell numbering)
xy <- xyFromCell(object = ras_bio_asc_01_cr, cell = cells)
xy
# coordinates(ras_bio_asc_01_cr)[cells,]
extract(x = ras_bio_asc_01_cr, y = xy)
# extract(ras_bio_asc_01_cr, cells)
## Change values, e.g. for adding forest or creating a corridor
## take care! -> irreversible! better work on a copy!
copy_ras <- ras_bio_asc_01_cr
copy_ras[cells] <- 250 # here we set all values in the raster at the position index cells to 250
plot(x = copy_ras, col = viridis(20))
## turn first into SpatVector - this is the format needed for the distance() function below
sv_xy <- vect(xy)
sv_xy
## calculate distance
my_dist <- distance(x = ras_bio_asc_01_cr, y = sv_xy)
## `distanceFromPoints(object = ras_bio_asc_01_cr, xy = xy)` in {raster}
plot(x = my_dist) ## units?
points(xy)
## nicer plot adding the points from which a distance should be computed.
## please ignore the following 4 lines, just run them,
## you will learn that when working with vector data below
xy_sf <- st_as_sf(x = sv_xy,
coords = c("x","y"),
crs = 4326,
sf_column_name = "geometry" )
tmap_mode(mode = "plot")
tm_shape(shp = my_dist) +
tm_raster(n = 100, palette = rev(grDevices::terrain.colors(100)),
legend.show = FALSE) +
tm_shape(shp = xy_sf) +
tm_dots(size = 1)
xy_sf
xy_sf <- st_as_sf(x = sv_xy,
coords = c("x","y"),
crs = 4326,
sf_column_name = "geometry" )
xy_sf
?st_as_sf
xy_sf <- sf::st_as_sf(x = sv_xy,
coords = c("x","y"),
crs = 4326,
sf_column_name = "geometry" )
xy_sf
sv_xy
xy
xy_sf <- sf::st_as_sf(x = xy,
coords = c("x","y"),
crs = 4326,
sf_column_name = "geometry" )
xy_sf <- st_as_sf(x = xy,
coords = c("x","y"),
crs = 4326,
sf_column_name = "geometry" )
xy
xy_sf <- st_as_sf(x = xy,
coords = c("x","y"),
crs = 4326,
sf_column_name = "geometry" )
st_as_sf(x = xy,
coords = c("x","y"),
crs = 4326)
xy_sf <- sf::st_as_sf(x = xy,
coords = c("x","y"),
crs = 4326,
sf_column_name = "geometry" )
class(xy)
typeof(xy)
sv_xy
xy_sf <- sf::st_as_sf(x = sv_xy)
xy_sf
xy_sf <- sf::st_as_sf(x = sv_xy, crs = 4326)
xy_sf
crs(xy_sf) <- "EPSG:4326"
crs(xy_sf) <- "+init=epsg:4326"
xy_sf <- sf::st_as_sf(x = sv_xy)
crs(xy_sf) <- "+init=epsg:4326"
crs(xy_sf) <- "epsg:4326"
## when working with raster data
## do NOT load both packages terra and raster at the same time,
## as this creates problems with the namespace
library(terra) ## the "new" {raster} package
library(rgdal)
library(rgeos)
library(rasterVis)
## working with vector data
library(sf) ## the "new" {sp} package
library(stars)
## visualization
library(ggplot2)
library(tmap)
library(viridis) ## nice colour palettes
library(patchwork) ## to combine plots
library(units) ## handle measurement data
library(here) ## for easy directory management
#install.packages("Rcpp", repos="https://rcppcore.github.io/drat")
## `distanceFromPoints(object = ras_bio_asc_01_cr, xy = xy)` in {raster}
plot(x = my_dist) ## units?
points(xy)
crs(sv_xy) <- "epsg:4326"
sv_xy
crs(sv_xy) <- "epsg:4326"
xy_sf <- sf::st_as_sf(x = sv_xy)
tmap_mode(mode = "plot")
tm_shape(shp = my_dist) +
tm_raster(n = 100, palette = rev(grDevices::terrain.colors(100)),
legend.show = FALSE) +
tm_shape(shp = xy_sf) +
tm_dots(size = 1)
cells1 <- c(cells, 250, 360) ## add two more points to cells = cells1
sv_xy_2 <- vect(xyFromCell(ras_bio_asc_01_cr, cells1))
my_dist <- distance(x = ras_bio_asc_01_cr, y = sv_xy_2)
plot(my_dist) #units?
## Border of countries and provinces of Borneo
## - only loading columns 1:3, 5, 7, 17, 18 of attribute table:
Borneo_shp <- st_read(dsn = vecs_wd, layer = "borneo_admin")[, c(1:3, 5, 7, 17, 18)]
## Protected Areas (National Parks, Nature Reserves, Forest Reserves)
PA_shp     <-  st_read(dsn = vecs_wd,
layer = "Bor_PA")[, c(1:4)]
## fix problematic polygons
PA_shp <- st_make_valid(PA_shp)
## main rivers
River_shp  <- st_read(dsn = vecs_wd, layer = "sn_100000")
### the 'old' sp package would work with the `readOGR` command from the `{rgdal}` package:
Admin_shp <- readOGR(dsn = vecs_wd, layer = "borneo_admin",)[,c(1:3,5,7,17,18)]
## transformations
Admin_sf <- as(Admin_shp, "sf")     ## from sp object to sf object
Admin_sp <- as(Admin_sf, "Spatial") ## from sf to sp object
## transformations
Admin_sf <- as(Admin_shp, "sf")     ## from sp object to sf object
Admin_sp <- as(Admin_sf, "Spatial") ## from sf to sp object
## Please note the similarity to accessing info from rasters.
str(object = ext(PA_shp)) ## `extent()` in {raster}
xmin(ext(PA_shp))
names(x = PA_shp) ## returns column names of a.t.
## Much more complex than sf-objects.
class(Admin_shp)
str(object = ext(Admin_shp))
xmin(ext(Admin_shp))
names(x = Admin_shp) ## returns column names of a.t.
summary(object = PA_shp)
str(object = PA_shp)
PA_shp
attributes(x = PA_shp)
head(x = PA_shp)
tail(x = PA_shp)
PA_shp[1, ] ## returns first entry (row) of all 4 columns
PA_shp[, 2] ## returns summary of col only!
PA_shp[1, ] ## returns first entry (row) of all 4 columns
PA_shp[, 2] ## returns summary of col only!
## PA_shp$NAME_ENG ## returns a long list
head(x = PA_shp$NAME_ENG) ## using fct head() to only show the first 6 entries
PA_shp[1, 1] ## = PA_shp$SITE_ID[1]
PA_shp[2, 3] ## = PA_shp$COUNTRY[2]
which(x = PA_shp$COUNTRY == 'Malaysia')
ggplot(data = PA_shp) +
geom_sf(fill = "chartreuse3", color = NA) +
labs(x = "Longitude", y =  "Latitude",
title = "Protected areas") +
theme_minimal(base_size = 15) ## set custom plot style
tmap_mode(mode = "plot")
tm_shape(shp = PA_shp[, 1]) +
tm_polygons(col = "SITE_ID", palette = grDevices::terrain.colors(5))
tmap_mode(mode = "view")
tm_shape(shp = PA_shp[, 1]) +
tm_polygons(col = "SITE_ID", palette = grDevices::terrain.colors(5))
# plot(Borneo_shp) ## not run
plot(Borneo_shp[,1]) ## select column
plot(Admin_sp)
# spplot(Admin_sp) ## Don't do that! Each column of the a.t. will be plotted
head(Admin_sp)
spplot(Admin_sp[6]) ## only plot one of the geometries, coloured e.g. by shape_length = column 6
tmap_mode(mode = "plot")
tm_shape(shp = Borneo_shp) +
tm_polygons(border.col = "deepskyblue4") +
tm_shape(PA_shp[,1]) +
tm_polygons(border.col = "black") +
tm_shape(PA_shp[1, ]) +
tm_polygons(border.col = "red")
Mal_PA_shp <- subset(PA_shp, PA_shp$COUNTRY == 'Malaysia')
st_write(obj = Mal_PA_shp,
dsn = output_wd,
layer = 'ProtectedAreasMalaysia',
driver = 'ESRI Shapefile',
delete_layer = TRUE)
fewPA <- Mal_PA_shp[c(1:5), 1]
tmp <- extract(x = ras_bio_asc_24, y = vect(fewPA), xy = TRUE) ## returns a list â€” each element contains the elevation raster cells (ras_bio_asc_24)
str(tmp)
#lapply(tmp, FUN = summary)
## a bit complicated:
# fewPA$mean_elevation <- round(x = unlist(lapply(tmp, FUN = mean, na.rm = TRUE)))
## ...or for now solved stepwise with aggregate()
mean_tmp <- aggregate(tmp$bio_asc_24, by = list(Category = tmp$ID), FUN = mean)
## dplyr approach:
#mean_tmp <- dplyr::summarize(dplyr::group_by(tmp, ID), x = mean(bio_asc_24, na.rm = TRUE))
fewPA$mean_elevation <- mean_tmp$x
fewPA
# st_area(x = Borneo_shp) ## returns long vector
head(st_area(x = Borneo_shp))
Borneo_shp_moll <-  st_transform(Borneo_shp, c("+proj=moll +datum=WGS84"))
class(Borneo_shp_moll) #sf object, data.frame!
head(st_area(x = Borneo_shp_moll)) ## units?
ggplot(Borneo_shp_moll) +
geom_sf(color = "blue") +
theme_minimal(base_size = 15) ## set custom plot style
Mal_Borneo_shp <- subset(Borneo_shp_moll, Borneo_shp_moll$NAME_0 == 'Malaysia')
head(st_area(x = Mal_Borneo_shp) / 1000000) ## or / 1e6
## better: use set_units to change the units from m^2 to km^2
Mal_Borneo_shp$area <- units::set_units(x = st_area(x = Mal_Borneo_shp), value = km^2)
head(Mal_Borneo_shp$area)
st_area(x = Borneo_shp_moll[3, ]) ## for a single polygon
head(st_area(x = Borneo_shp_moll, byid = TRUE)) ## for all polygons
area_km2 <- set_units(x = st_area(x = Borneo_shp_moll, byid = TRUE), value = km^2)
Borneo_shp_moll = data.frame(Borneo_shp_moll, area_km2)
head(x = Borneo_shp_moll)
#gArea(Borneo_shp_moll, byid=TRUE) / 1e6 ## does not work, as Borneo_shp_moll is sf-object!
head(rgeos::gArea(Admin_sp, byid = TRUE) / 1e6) ## what does the warning message mean? -> check crs!
Admin_sp_moll <- spTransform(Admin_sp, c("+proj=moll +datum=WGS84"))
head(rgeos::gArea(Admin_sp_moll, byid = TRUE) / 1e6) ## now it works!
pt_shp <- st_read(dsn = paste0(recs_wd, "/FCsim.shp"))
pt_shp  ## crs is missing!
st_crs(pt_shp) <- 4326 ## set it with command st_crs()
pt_shp
recs_wd
pt_shp <- st_read(dsn = paste0(anim_wd, "/FCsim.shp"))
pt_file <- paste0(anim_wd, "/MyNewSpecies.csv")
df_recs <- read.table(file = pt_file, header = TRUE, sep = ',')
class(x = df_recs)
head(x = df_recs)
plot(x = as(Borneo_shp, "Spatial"), col = 'grey', border = 'white') ## polygon
points(x = df_recs$long, df_recs$lat, cex = 0.5, pch = 15) ## simple d.f.!
plot(x = as(pt_shp, "Spatial"), col = 'blue', add = TRUE)
recs_sf <- st_as_sf(x = data.frame(df_recs),
coords = c("long", "lat"),
crs = 4326,
sf_column_name = "geometry")
## retrieve the geometry (location) indices of PA_shp at
## the locations of sp_recs: which points are in PA_shp
nrow(recs_sf) ## 500
insidePA <- st_intersection(x = recs_sf, y = PA_shp)
nrow(insidePA) ## 11
# for a RASTER: extract mean ann. temp. from ras_bio_asc_01
# and add it to a.t.of the locations/ points
mean_t <- extract(x = ras_bio_asc_01, y = vect(recs_sf)) ## for {terra} we need to wrap the sf object into spatial vector with`vect()`
recs_sf$mean_t <- mean_t$bio_asc_01
mean(x = recs_sf$mean_t) # hist(sp_recs_sf$mean_t)
st_write(obj = insidePA,
dsn = output_wd,
layer = "inPA",
driver = "ESRI Shapefile",
delete_layer = TRUE)
library(rnaturalearth)
## store as sp object (SpatialPolygonsDataFrame)
world <- ne_countries() ## `returnclass = "sp"` by default
class(world)
## store as sf object (simple features)
world <- ne_countries(returnclass = "sf")
class(world)
sf::st_crs(world)[1]
names(world)
ggplot(world) + geom_sf(aes(fill = economy)) + theme_void()
glacier_small <- ne_download(type = "glaciated_areas", category = "physical",
scale = "small", returnclass = "sf")
glacier_large <- ne_download(type = "glaciated_areas", category = "physical",
scale = "large", returnclass = "sf")
ggplot(glacier_small) +
geom_sf(color = "grey40", fill = "grey40") +
theme_void()
ggplot(glacier_large) +
geom_sf(color = "grey40", fill = "grey40") +
theme_void()
relief <- ne_download(type = "MSR_50M", category = "raster",
scale = 50, returnclass = "sf")
plot(relief)
?ne_download
library(rnaturalearth)
## store as sp object (SpatialPolygonsDataFrame)
world <- ne_countries() ## `returnclass = "sp"` by default
class(world)
## store as sf object (simple features)
world <- ne_countries(returnclass = "sf")
class(world)
sf::st_crs(world)[1]
spdf_world <- ne_download( scale = 110, type = 'countries' )
if (require(sp)) {
plot(spdf_world)
plot(ne_download(type = 'populated_places'))
}
glacier_small <- ne_download(type = "glaciated_areas", category = "physical",
scale = "small", returnclass = "sf")
glacier_large <- ne_download(type = "glaciated_areas", category = "physical",
scale = "large", returnclass = "sf")
ggplot(glacier_small) +
geom_sf(color = "grey40", fill = "grey40") +
theme_void()
ggplot(glacier_large) +
geom_sf(color = "grey40", fill = "grey40") +
theme_void()
relief <- ne_download(type = "MSR_50M", category = "raster",
scale = 50, returnclass = "sf")
plot(relief)
library(osmdata)
## explore features + tags
head(available_features())
head(available_tags("craft"))
## building the query, e.g. beekeepers
beekeeper_query <-
## you can automatically retrieve a boudning box (pr specify one manually)
getbb("Berlin") %>%
## build an Overpass query
opq() %>%
## access particular feature
add_osm_feature("craft", "beekeeper")
## download data
sf_beekeepers <- osmdata_sf(beekeeper_query)
names(sf_beekeepers)
head(sf_beekeepers$osm_points)
beekeper_locations <- sf_beekeepers$osm_points
ggplot(beekeper_locations) +
geom_sf(data = d6berlin::sf_berlin) +
geom_sf(size = 2) +
theme_void()
library(elevatr)
## manually specify corners of the bounding box of the US
bbox_usa <- data.frame(x = c(-125.0011, -66.9326),
y = c(24.9493, 49.5904))
## turn into spatial, projected bounding box
sf_bbox_usa <- st_as_sf(bbox_usa, coords = c("x", "y"), crs = 4326)
elev_usa <- get_elev_raster(locations = sf_bbox_usa, z = 5)
plot(elev_usa)
myraster       <- terra::rast()
myshapefile    <- sf::st_read()
myxydataframe  <- sf::st_as_sf()
world
?units
?date
writeRaster(x = Bor_hs,
filename = paste0(output_wd,"/hillshade.asc"),
# or use here: here("output", "hillshade.asc")
overwrite = TRUE,
NAflag = NA)
## save the small cropped file
writeRaster(x = Bor_hs,
filename = paste0(output_wd,"/hillshade.asc"),
# or use here: here("output", "hillshade.asc")
overwrite = TRUE,
NAflag = -255)
## save the small aggregated file
writeRaster(x = ras_bio_asc_01_agg,
filename = paste0(output_wd,"/bor_agg.asc"),
# or use here: here("output", "bor_agg.asc")
overwrite = TRUE,
NAflag = -9999)
## save the small aggregated file
writeRaster(x = ras_bio_asc_01_agg,
filename = paste0(output_wd,"/bor_agg.asc"),
# or use here: here("output", "bor_agg.asc")
overwrite = TRUE,
NAflag = 1)
ras_bio_asc_01_agg
ras_bio_asc_01_agg@data@values
values(ras_bio_asc_01_agg)
