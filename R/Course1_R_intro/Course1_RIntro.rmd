---
title: "Tutorial Part I - Quick introduction to R"
author: "Stephanie Kramer-Schadt, Alex Courtiol, Moritz Wenzler, Cedric Scherer"
date: "`r Sys.setlocale('LC_TIME','C'); paste('Last Update', format(Sys.time(), '%B %e, %Y'))`"
output:
  rmdformats::readthedown:
    highlight: kate
    code_folding: show
    toc_depth: 4
    toc_float: true
editor_options:
  chunk_output_type: console
params:
  date: !r Sys.Date()
---

<style>
h1 {
  color: Orange ;
}
h2, h3, h4, h5, h6, legend {
  color: Indigo ;
}
p {
  line-height:170%;
}
#sidebar h2 {
  background-color: Indigo;
}
code {
  color: Indigo ;
}
.exercise {
  color: #824b00;
}
</style>

---

```{r setup, include=FALSE}
# DO NOT RUN THIS CHUNK IN R CONSOLE
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, 
                      fig.width = 9, fig.height = 6, dev = "ragg_png")
knitr::opts_knit$set(root.dir = 'C:/Users/kramer/PopDynCloud/StephKramer/projects_github/d6_teaching_collection')
#or on GUI: knit -> knit directory -> project directory
```



# Basics

The first outline of this course has been developed in 2012 by Alex Courtiol and has ever since 'evolved' in courses I gave and polished by Moritz and Cedric. This short intro contains the most important commands and functions to handle and manipulate data and to follow the course `biodiversity dynamics`.
<br> 


Disclaimer: This is not a beginner's course to learn R! To deepen your R skills, I recommend one of the tutorials of <br> 

* https://ourcodingclub.github.io/tutorials.html <br>
* https://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf  <br>
* https://www.r-bloggers.com/list-of-free-online-r-tutorials/ <br>
* https://raw.githubusercontent.com/ColauttiLab/RCrashCourse_Book/master/ColauttiRCrashCourseNov22.pdf <br>

I am actually a big fan of `R` cheat-sheets which provide the basic functions in an overview format. For this course, please download (and use) the [base R cheatsheet](https://iqss.github.io/dss-workshops/R/Rintro/base-r-cheat-sheet.pdf).
<br>

If you have downloaded the whole course folder, the easiest is to double-click on the 
`R`-project file `d6_teaching_collection.Rproj`. Go to `File` &rarr; `New File` &rarr;` R` script (or `R Markdown`) to open an empty script and save it under a different name.
<br>

Then type or copy-paste the code lines in the grey boxes of the provided `Course1_RIntro.rmd` OR `Course1_RIntro.html` file into your `R` script, run the lines and follow the course... For learning reasons, I actually recommend to even type the functions and commands 'by hand' and not only run the code by clicking the code lines in the .rmd file.
<br>


## Setting the work directory

If you have opened the `R`-Project, the working directory is automatically set to the root directory (= `d6_teaching_collection`).




<details><summary>Optional - set work directory manually</summary>

### Optional - set work directory manually

For advanced `R`users only: Please set your OWN working directory **only** if you have **not** used our folder structure or opened the R-Project as described above. That is, you have to set manually the path in your computer to the folder where you want to save your course script and material. In the following, I have disabled the command lines with `#` so that the
course folder structure is not destroyed if you accidentally run the following lines.

```{r, eval=FALSE}
# check where you are on your PC with getwd() = get working directory:
getwd()
```

E.g., the output could be: `'C:/yourname/somewhere'`.
Then, change the work directory (wd) to your folder by setting the work directory (wd) explicitly with the function `setwd()`.

```{r, eval=FALSE}

# setwd('C:/IZW/github_local_Mdrive/d6_teaching_collection') # adjust and run the line!

```


</details>


To keep folders clean, store all output in a separate folder called `output`. First, create the path to the folder:

```{r}

#- adjust and run the line if you are NOT using our folder structure
#- ignore this line if you work in our downloaded repository structure
# output_wd <- "M:/IZW/github_local_Mdrive/d6_teaching_collection/output") 


## More elegantly with the function paste0() which is pasting text strings together:
## first store your root folder in a name object:

root_wd <- getwd() # the root folder 
output_wd <- paste0(root_wd,"/","output")

```

Please note: for now, this is just text (a character string denoted with ' ') pointing to a location in your directory, not yet a folder! Create the folder either in your explorer manually, or more elegantly with `dir.create()`. To avoid overwriting existing folders, ask first if the folder exists. This should be the case when you work in the downloaded  repository folder structure.

```{r}
dir.exists(output_wd)
# if it does not exist, then create it:

# dir.create(output_wd) # run line if needed -> creates folder 'output'
 
```




## Basics: R for calculus

Use hashtags # for comments

```{r}
# "comment"
1 + 1
# store calculus etc in an object called 'what_is_one_plus_one'
what_is_one_plus_one <- 1 + 1
# display result
what_is_one_plus_one
# assign character
what_is_one_plus_one <- 'two'
```


## Basics: Common mistakes

### Spelling - Case sensitivity

```{r}
# Find the errors - try these lines
#What_is_one_plus_one
#what_is_one_plusone
#what_is_one_plus_two
```


### Wrong assignment

```{r, eval = FALSE}
1 + what_is_one_plus_one
# why does this not work?

1 + what_is_one_plus_one <- 1 + 2
# nor this?
```


### Correct assignment

```{r}
what_is_one_plus_one <- 1 + 1
1 + what_is_one_plus_one
```


## Basics: Getting help


Get used to working with `?` or `??` in front of a function to learn to work with the `R` help. In the following, the example shows how to get help to know how R should be cited with the function `citation()`.

```{r, eval=FALSE}
# <function_name> or <function_name>() shows the function
citation() # how to cite R
?citation() # getting help use ? (or??) or
help(citation) 
# or place cursor on function and press F1
```


## Basics: Functions 

Functions are in most cases indicated by ()

```{r, eval=FALSE}
mean() # what's wrong?
```

This function needs further parameters (called *Arguments* in the help)

```{r, eval=FALSE}
?mean() # which parameters are needed? 

# The function actually needs data (= x), e.g. in form of a data vector, that will be handed over with the argument x
```


### Assign values to the function

```{r}
#- Use the command 'c' (= concatenate)
#- it combines values into a vector or list to create 'data'
vector_of_numbers <- c(22, 65, 101, 86, 110)
# e.g. wingspan of dragonflies in mm 
vector_of_numbers
mean(x = vector_of_numbers)
```


### Arguments

Arguments for functions are described in the help of `R`.
```{r}
mean(x = vector_of_numbers) # n.b. better use argument names (x= ...)

# since x is the first argument in the parentheses of the function, 
# you could also omit it, e.g. simply write
mean(vector_of_numbers)
# but this is not recommended, because it leads to errors, 
# especially when it comes to spatial plotting
```

```{r, eval = F}
mean(y = vector_of_numbers) # what's wrong?
```

```{r}
# analogously: more useful functions/ commands:
sqrt(x = vector_of_numbers) # exp(), sin(), log()...
sum(x = vector_of_numbers)

# If you do not understand what the functions do, call help by running
# ?sum()
```


### Applying functions

Very helpful if you want to add data or change the value of existing data. We are assigning our numbers now to an object which will contain the wingspans (wsp) of dragonflies (drfly) (in mm).


<img src="http://phylopic.org/assets/images/submissions/00415ca0-dbca-4312-b871-840fe1c7031b.512.png" width="100" />




```{r}
# Assign the assigned values, i.e. simply 'copy' the values to a new object
wsp_drfly <- vector_of_numbers # wingspan of dragonflies
wsp_drfly
mean(x = wsp_drfly)

# Adding data, e.g. new measurements
wsp_drfly2 <- c(vector_of_numbers, wsp_drfly, 69 ,73)
wsp_drfly2

# tip of the day: when you want to see the output of a line directly, 
# put everything into parentheses:
(wsp_drfly2 <- c(vector_of_numbers, wsp_drfly, 69 ,73))
```


## Useful functions for analysis

```{r}
table(wsp_drfly2) # returns the counts of the measurements - like pivot in excel
sort(x = wsp_drfly2)
min(wsp_drfly2) #analogously: max, var, sd, range, median
```


```{r}
unique(x = wsp_drfly2) # n.b. - does not sort vector
```


You can also nest functions in functions. The inner function is evaluated first: 
```{r}
sort(unique(x = wsp_drfly2)) # first get unique numbers, then sort them
```


```{r}
length(x = wsp_drfly2) # length of data vector
summary(object = wsp_drfly2) # helpful function for a quick summary statistics overview
```


## Operators 

### Arithmetic operators

What happens: the mathematical operation is applied to each element (= measurement) in your vector (note the difference to a function like `sum()`, which was summing the values of the vector).

```{r, eval=-1}
?Arithmetic
wsp_drfly2 * 2
wsp_drfly2 * 10 - 100
```


### Logical operators

```{r, eval=-1}
?base::Logic     # overview over logical operations
wsp_drfly2 > 10  # >=, <, <=, &, | , !=, ==
wsp_drfly2 == 75 # n.b. difference to = or <- !!!!

# wsp_drfly2 == 75  # IS the value (or which one) EQUAL to 75 ?
# wsp_drfly2 <- 75  # assign the object wsp_drfly2 the value 75 # NOT RUN !
# wsp_drfly2 = 75   # same as <-  # NOT RUN !
```
<br>


# Data Types and Data Manipulation 

## Create Data Set with Vectors

Do the following so that we create a big data file, which will be called 'wsp_table', and which will contain the wing spans of butterflies and dragonflies.


<img src="http://phylopic.org/assets/images/submissions/ab6182d2-5093-444b-92e5-84468218ebf0.512.png" width="100" />


#### Repeat data with command `rep()`


```{r}
#- wingspan of butterflies in mm 
wsp_butfly2 <- c(12, 48, 79, 135, 189, 88, 15, 63, 21, 81, 148, 50)
```

In the following code line, we extract the length of this  data vector 'dynamically', that means depending on potential changes in the data. We have 12 measurements. You could of course directly write '12' into the code lines for creating the vector 'insect_type' (see below), but it is not recommended to write fixed values into code. Imagine you add one more measure into your `data.frame` in the next field season: if you still would use the fixed value of 12, this new measurement would not be included into your `data.frame` or analysis. So please code dynamically as much as possible (and if that is not possible, define the variable globally at the very beginning of your code. but this is another story which will be told another time).
```{r}
data_length <- length(x = wsp_butfly2) # 12 -> dynamic variable data_length
wsp <- c(wsp_drfly2, wsp_butfly2)
#- everything is in one line (vector) and we do not know whether 
#- the measurement belongs to dragonfly or butterfly
#- we therefore repeat the info 'data_length' (=12) times

#- code with dynamic variables:
insect_type <- factor(x = c(rep('dragonfly', data_length),
                            rep('butterfly', data_length)))
#- note the correct position of parentheses when functions are nested!
#- The rainbow parenthesis option in RStudio helps (see main course homepage)
insect_type
```


## Dataframe [df]

We now create a `data.frame`object, which is similar to an excel table with rows (= first dimension) and columns (= second dimension).
```{r, tidy=TRUE}
wsp_table <- data.frame(wingspan = wsp, insect = insect_type)
head(x = wsp_table) # head() returns first rows # tail() - last rows
# wsp_table
```


```{r, tidy=TRUE}
## Retrieving data from df
str(object = wsp_table)
```


```{r, tidy=TRUE}
wsp_table$wingspan # access columns with dollar $ sign
```

<h3 class='exercise'>Question Q1.1</h3>
**What is the average wingspan of both dragonflies and butterflies?**
<br>

use `wsp` to answer Q1.1.
<br>


### Indexing elements

This is an important part to understand how you can access single values within your `R`-objects, e.g. `data.frame`s; it is related to the *dimensions* of your objects. Indexing works with  these `[`   `]`  parentheses.


#### Indexing a vector[element]

Remember the first vector we created? It is just a dimensionless, single line. Now we want to know what the value of the third element is: 
```{r}
vector_of_numbers[3]
```

#### Indexing with [row,column]

`data.frame`s have two dimensions, rows and columns. Our wingspan table has two dimensions, i.e. 24 rows and 2 columns, with the first column holding the measurements, and the second the insect type.
```{r}
dim(wsp_table)
```

Now you can use this info to point to certain row/column combinations. Note: the *comma* is separating the dimensions, so always put commas at the correct place! 
```{r}
wsp_table[2, 2] # == wsp_table$insect[2]   # alternative !
wsp_table[2, 1] # == wsp_table$wingspan[2] # alternative !
```

If you leave the space before or after the comma empty, you will get the whole content of the table, i.e. the whole row or the whole column content. Try it out:
```{r}
wsp_table[2, ]
```

```{r}
wsp_table[, 2]
```

```{r, eval = FALSE}
wsp_table[, 3] # what's wrong?
```


You can also retrieve more than one value, i.e. here the information on the insect type for three row lines 2 - 5. 
```{r}

wsp_table[2:5, 2]
```

Remember what you need to do if you want to create to non-consecutive elements, i.e. elements 2, 6,7,8? You cannot use the *comma* to list them, because this would ask for another dimension. Solution, use the function `c()`.

```{r}
wsp_table[c(2,6:8), 2]
```

Can we do the same for dimensionless vectors:
```{r}
vector_of_numbers[c(1, 3:5)]
# why c(...)? Because the comma is another dimension.
# dimension in R: [row, column]
# Not run: vector_of_numbers[1, 3:5] #error
```


### Data.frame queries

R contains a lot of in-built functions to make data queries simple.


#### Function `tapply` / table apply 

**What is the average wingspan PER insect species?**

To answer this, we first must subset the data and select (index) columns with the two different insect types:
```{r}
mean(x = wsp_table$wingspan[wsp_table$insect == 'dragonfly']) # == !
mean(x = wsp_table$wingspan[wsp_table$insect == 'butterfly']) # == !
```

The function `tapply()` does this in one row, and you could also use other functions specified in the argument `FUN`.
```{r}
tapply(X = wsp_table$wingspan, INDEX = wsp_table$insect, FUN = mean)
```

Do you remember the other function we already had to retrieve some standard information of your data? But mind the difference! `summary()` works per column, that is, here it does not distinguish between the insect types. To get the summary-statistics of each insect, the information per insect must be stored in separate columns. We will come to that later.
```{r}
summary(wsp_table)
```



#### Subsetting 
If you only want to work with a part of your data

##### simple: function `subset`

Make a table with data where the wingspan of insects is smaller 65 mm.
```{r}
wsp_sub <- subset(x = wsp_table, subset = wsp_table$wingspan <= 65)
nrow(wsp_sub) # try also: dim(wsp_sub),dim(wsp_sub)[1]
wsp_sub
```

##### A bit more complicated: function `which`

This function does not return a subset `data.frame`, it only returns the index to the respective elements, i.e. in the following case all rows containing the requested information (wingspan <= 65). 

```{r}
(wsp_tmp <- which(x = wsp_table$wingspan <= 65))
```

To then get the information of the whole data set, you need to insert the index into the `data.frame` again. Have a look at the row numbers.
```{r}
(wsp_which <- wsp_table[wsp_tmp,] )
```

### Data Manipulation

#### Removing rows/columns 

Omit rows using a minus sign

```{r}
x <- wsp_which
x
x2 <- x[-c(1, 3), ] # remove rows 1 and 3
x2
```


Omit columns

```{r}
x22 <- x$wingspan # removes (actually keeps) columns
x22
```

#### Adding rows/columns I

##### Combine data (rows) with `rbind()`

This adds rows.
```{r}
x3 <- rbind(x2, wsp_table)
x3[1:10,] # n.b. new row names 1 and 25 !
```

##### Combine data (columns) with `cbind()`

This combines data to columns.
```{r}
x4 <- cbind(vector_of_numbers[1:3], vector_of_numbers[3:5])
x4
colnames(x4) <- c('col1', 'col2')
rownames(x4) <- c('A', 'B', 'C')
x4
```

## List

Lists have the advantage that data can be of different length to be combined into an object, e.g. 10 measurements of dragonflies, and 12 of butterflies.


#### List per grouping factor (here: insect type)

Now we have created a list where each element contains the measurements per insect_type.
```{r}
wsp_list <- list(dragonfly = wsp_drfly2, butterfly = wsp_butfly2)
str(wsp_list)
```

Also here, we can retrieve summary statistics, however we must use the functions written for `list`-objects.
```{r}
wsp_list$dragonfly # == wsp_list[['dragonfly']]
lapply(X = wsp_list, FUN = mean) # OR: mean(wsp_list$dragonfly)
```

## Matrix 

Matrices are a third data type very useful for mathematical operations, or to plot spatial raster data.

Definition per row or col, looses headers (rownames and colnames!

matrix setup per row see argument `nrow` : 
```{r}
wsp_matrix <- matrix(data = c(wsp_drfly2, wsp_butfly2), nrow = 2)
wsp_matrix
# Does this format ring a bell?? -> spatial raster data
```

The matrix has lost rownames and colnames. You can define them again and then make queries based on the names again.
```{r}
rownames(x = wsp_matrix) <- c('dragonfly', 'butterfly')
wsp_matrix[, 1]
wsp_matrix['dragonfly', ] # == wsp_matrix[1, ]
```

matrix setup per column see argument `ncol`:

```{r}
wsp_matrix <- matrix(data = c(wsp_drfly2, wsp_butfly2), ncol = 2)
wsp_matrix
#head(wsp_matrix)
#str(wsp_matrix)
```

Analoguously to above, you can query the matrix elements with `[` `]` or set column names and do the query based on names.

```{r}
wsp_matrix[, 1]
colnames(x = wsp_matrix) <- c('dragonfly', 'butterfly')
#wsp_matrix$dragonfly
wsp_matrix[, 'dragonfly'] # == wsp_matrix[, 1]
```

#### Extracting data from matrix 

Similar to `tapply()` and `lapply()`, the function `apply()` works for matrices:
```{r}
#- use the matrix with column setup
# wsp_matrix <- matrix(c(wsp_drfly2,wsp_butfly2), ncol=2)
# colnames(wsp_matrix) <- c('dragonfly','butterfly')

mean(x = wsp_matrix[, 1])
apply(X = wsp_matrix, MARGIN = 2, FUN = mean)
```

<h3 class='exercise'>Question Q1.2</h3>

**What is meant with 'MARGIN = 2'? Check the help!**
<br>
**What happens if you use 1 instead?**
<br>


## Missing Data NA

Sometimes (very often in ecology) we have missing data. Understanding how to handle missing data (NA - not available) is important.
```{r}
wsp_fly2 <- c(1, 5, 4, 11, 8, 2, NA, 4, 2, 9, 8, NA) # another insect type
mean(x = wsp_fly2)
# type ?mean
```

Why doesn't it return a value? Because R does not want to automatically omit them, you have to specify how to deal with NAs:

```{r}
# How to deal with missing data?
mean(x = wsp_fly2, na.rm = TRUE) # NA remove = TRUE -> remove NAs
```

```{r}
wsp_l <- list(dragonfly = wsp_drfly2, butterfly = wsp_butfly2, fly = wsp_fly2)
lapply(X = wsp_l, FUN = mean)
lapply(X = wsp_l, FUN = mean, na.rm = TRUE)
```

## Data Manipulation: Summary

Check the type of objects you are working with. This is very helpful especially when working with spatial data types.
```{r}
#- TRY
class(wsp_table) ; class(wsp_matrix) ; class(wsp_list)
#-  on vectors: 
class(insect_type) ; class(wsp_l$dragonfly)
#- on skalars: 
class(what_is_one_plus_one)
```
For effective data manipulation, learn the `tidyverse` piping language which comes with packages such as `dplyr` and `broom`.
<br>

# Managing Data 

## Saving and Reading Files 

The files will usually be stored under your working directory. Here, we want to have a clean structure and store everything in the output folder.At the beginning of the course, we created the path to the output folder as a character string (called 'output_wd'). We can directly append the file name to that string, so that the file will be stored in the folder.
```{r}
getwd() # cross-check whether you are in the root folder 

(wsp_filename <- paste0(output_wd,"/","wsp_table.csv") ) 
write.csv(x = wsp_table, file = wsp_filename, row.names = FALSE)
```


In the same way, .txt , .csv etc. files can be read/ loaded.
```{r}
wsp_reloaded <- read.csv(file = wsp_filename, header = T)
head(x = wsp_reloaded)

```

<br>

# Plotting with R 

## Plotting: Basics

### `plot()` 

is the universal function for scatter plots or line diagrams

```{r}
#- the table also contains character strings / factors, so plot looks ugly
plot(x = wsp_table)

#- solution
plot(x = wsp_table$wingspan)
```


Use command `ifelse` to define colors PER species. Create a new object 'color_for_insect_type', which will contain the colour 'red' if it is a dragonfly, else it will be blue. Note that you need to specify a colour for each line!
```{r}
color_for_insect_type <- ifelse(wsp_table$insect == 'dragonfly', 
                                yes = 'red', no = 'blue')
#- add argument for color: col = color_for_insect_type
plot(x = wsp_table$wingspan, col= color_for_insect_type)
```

Check the [R colour cheat sheet](https://www.nceas.ucsb.edu/sites/default/files/2020-04/colorPaletteCheatsheet.pdf) if you are interested in colour options. R has 657 built-in colour names.
```{r}
#- example. More on the cheat sheet on page 3
colors()[1:4]
```



### `par()` to pimp up your plot

Change the graphical parameters to change the style of your plot. Please explore yourself what `cex`, `cex.lab`, `las`, `pch` etc. means by using the help
```{r, eval=-c(2,3)}
# now have a look at
?base::plot # and
?par # of how to make the plots more pretty and how to set graphical parameters

plot(x = wsp_table$wingspan, col = color_for_insect_type, pch = 3,
      xlab = "unsorted values", ylab = "wsp [mm]", cex = 3,
      cex.lab = 1.5, cex.axis = 1, las = 2,
      col.axis = "blue")
```

## Plotting: Practical thingies 

### Abline - Drawing lines 

into plots (h=horizontal, v= vertical, or "intercept, slope" of regressions)

```{r, eval=-1}
?abline
plot(x = wsp_table$wingspan, col = color_for_insect_type)
abline(v = 12.5, lty = "dashed", col = "red") #lty = line type
abline(h = 75, lty = "dotted")
```


### Drawing *arrows* and adding *text*

```{r}
plot(x = wsp_table$wingspan, col = color_for_insect_type,pch = 16, cex = 3)
arrows(x0 = 5, y0 = 125, x1 = 5, y1 = 82, col = "purple")
arrows(x0 = 15, y0 =  70, x1 = 17, y1 =  75, col = "black", lwd = 3) #lwd=line width
text(x = 3, y = 70, labels = "DRAGONFLY",cex=0.8)
```

## Other plot types

First, create new data set called " mydata" with new column "wind_speed":
```{r}
wind_speed <- rep(x = 50:70, length.out = nrow(wsp_table))
mydata <- cbind(wsp_table, wind_speed)
head(x = mydata)
```

### `boxplot` and histogram (`hist`)

We want to plot both plots next to each other, so we have to separate the plotting
panel into two columns. This is done within the graphical parameters (`par()`) with the argument `mfrow()`, which is treating the panel like a table where we can specify the number of rows and columns.
```{r}
par(mfrow = c(1, 2))   # one row, two columns
# par(mfrow = c(2, 1)) # what happens here? try it out
boxplot(formula = mydata$wingspan ~ mydata$wind_speed)
hist(x = mydata$wingspan, main = '')
par(mfrow = c(1, 1))   # remember to set plotting area back 
```

### `hist` continued — the role of breaks and `freq = FALSE`

Breaks group the data, frequency is the count of data falling into the groups. 
If `freq = FALSE` the density is plotted, i.e. the share of each group summing to 1.
In the second example, the data spanning the range from 12-189 is divided into 59 breaks (by = 3), so only one or two data points fall into a break.

```{r}
par(mfrow = c(1,2))
hist(x = mydata$wingspan, breaks = 2, main = '')
hist(x = mydata$wingspan, 
     breaks = seq(min(mydata$wingspan),
                  max(mydata$wingspan), 
                  by = 3), 
     freq = FALSE, col = 'lightgrey', main = '')

par(mfrow = c(1, 1))
```

It is also possible to save the results of the histogram in an object:

```{r}
my_h <- hist(x = mydata$wingspan, 
             breaks = seq(min(mydata$wingspan), 
                          max(mydata$wingspan), by = 3), plot = FALSE)
my_h
```


### `barplot`


The barplot counts unique values (difference to histogram, which counts data points falling into break ranges )
```{r}
my_bp <- table(mydata$wingspan)
my_bp # note the difference to histograms ($counts)!
barplot(my_bp) 
```


### Conditional plot `coplot`

```{r}
coplot(formula = mydata$wingspan ~ mydata$wind_speed | mydata$insect, pch = 16)
```


## Plotting: Margins and multiple figures

### Graphics device division

```{r}
#- mar = margin of figure in blue, oma = outer margin in green
#- mar/ oma go from below, left, above, right around the figure 
par(mfrow = c(1, 2), mar = c(5, 4, 1, 1), oma = c(1.5, 2, 1, 1))
plot(x = mydata$wingspan, col = color_for_insect_type, pch = 16, cex = 3)
boxplot(formula = mydata$wingspan ~ mydata$insect)
box(which = 'plot', col = 'red')
box(which = 'figure', col = 'blue', lty = 'dashed')
box(which = 'outer', col = 'green' , lwd = 5)
```

## Saving Plots

works for jpg, pdf, png, wmf and postscript and is extremely helpful for making the figures for manuscripts, theses etc.
Btw: You won't see the plot in the panel, it is directly stored in the output folder. Run the code and check!

```{r, eval=FALSE}
#- Single Plot
pdfname <- paste0(output_wd, "/my_plot1.pdf") # store in  output folder
pdf(file = pdfname, width =  5, height = 5)
coplot(formula = wingspan ~ wind_speed | insect, 
       data = mydata, pch = 16)
dev.off()

#- Multiple Plot
jpeg(file =  paste0(output_wd,'/my_jpg.jpg')) #don't forget the /
par(mfrow = c(1, 2))
barplot(my_bp, col = rainbow(17), main = 'Barplot', xlab = 'wingspan', ylab = 'Count')
hist(x = mydata$wingspan, 
     breaks = seq(min(mydata$wingspan), 
                  max(mydata$wingspan), 
                  by = 3), 
     freq = TRUE, 
     col = rainbow(6))
dev.off()
```

## Fancy plotting with R-package `{ggplot2}`

Let's be honest, the above plots are ugly. For making nice plots you can use in 
your thesis or publications, change to R-package ´{ggplot2}´. R-packages are libraries with pre-coded functions. You first need to install them using function `install.packages()` and then load them using `library()` or `require()`.
<br>

I strongly recommend the course by Cedric Scherer on `ggplot2`:  
* https://www.cedricscherer.com/2019/08/05/a-ggplot2-tutorial-for-beautiful-plotting-in-r/
<br>
or by the coding club:
<br>
* https://ourcodingclub.github.io/tutorials/trends-analysis-dataviz/
<br>

The `ggplot` language works in layers to be built and added. First, load the library, and plot the canvas for 'mydata':

```{r}
# install.packages('ggplot2') #run this if needed
library(ggplot2) # load the library; don't forget to install the package before
ggplot(data = mydata) # nothing happens but a grey panel appearing with the extent of the data
```

Now, add layers with the '+' sign. First, specify the type of plot (geom_point),
and then which column to plot and how they should look like with 'aes', 
standing for 'aesthetics':

```{r}
ggplot(data = mydata, mapping = aes(x = wind_speed, y = wingspan)) + 
  # everything related to the data should be in the aesthetics (aes)
  geom_point() 
```

Thanks to implicit matching you can also write the following which you will often 
find in tutorials etc.

```{r}
ggplot(mydata, aes(wind_speed, wingspan)) + # data, mapping(x, y)
  geom_point() 
```

Pimp up the plot, look at the specifications e.g. here:
https://ggplot2.tidyverse.org/articles/ggplot2-specs.html

```{r}
ggplot(mydata, aes(x = wind_speed, y = wingspan)) + 
  geom_point(
    shape = 17,
    size = 5,
    col = 'gray40',
    alpha = 0.5
  )
```

If you like the look, you can even store this plot in an object

```{r}
myggplot1 <- 
  ggplot(mydata, aes(x = wind_speed, y = wingspan)) + 
    geom_point(
      shape = 17,
      size = 5,
      col = "red",
      alpha = 0.4 # makes shapes transparent - nice if points overlap
    )

#to plot, call the object
myggplot1
```

Add the labels, and your favourite plotting theme:  
https://ggplot2.tidyverse.org/reference/ggtheme.html
or check 'library(ggthemes)'

```{r}
myggplot1 + 
  labs(x = 'Wind Speed', y = 'Wing span [mm]') + 
  theme_dark()
```

Btw, you can also set themes globally so that all following plots use the same
theme (if not specified individually):

```{r}
theme_set(theme_light(base_size = 15))
```

(With the argument base_size, you are now overwriting the theme's size for fonts and a few other theme elements.)

Now make the plot per insect with `facet`:

```{r}
myggplot1 +
  facet_grid(. ~ insect) + 
  labs(x = 'Wind Speed', y = 'Wing span [mm]')
```

Now, make a nice boxplot adding the points with `geom_jitter()`:

```{r}
ggplot(mydata, aes(x = insect, y = wingspan, color = wind_speed)) +
  geom_boxplot() +
  geom_jitter(width = .1, alpha = .5,size=5) + 
  labs(x = "Insect taxon", y = "Wing span [mm]")
```

An informative alternative are violin-plots:

```{r}
# mind where the color argument is set now: because different colours 
# should be used for the violin plot and the jitter dots.
ggplot(mydata, aes(x = insect, y = wingspan)) +
  geom_violin(fill = "gray80", size = 1, alpha = .5) +
  geom_jitter(color = 'grey50',width = .1, alpha = .5, size=10) + 
  labs(x = "Insect taxon", y = "Wing span [mm]")
```

Or another beautiful possibility, the ridge plot. Please note: this is a density plot, forcing beginning and end through zero. But: we never measured wing spans of zero! So be careful when using this plot.

```{r}
library(ggridges) # install package first if needed with install.packages()
ggplot(mydata, aes(x = wingspan, y = factor(insect))) +
  geom_density_ridges(fill = "gray90") +
  labs(x = "Wing span [mm]", y = "Taxon") +
  theme_light()
```

And really great for data visualisation is [`{ggdensity}`](https://jamesotto852.github.io/ggdensity/). Check it out! It plots the density of points.

```{r}
# install.packages("ggdensity")
library(ggdensity) # 
ggplot(mydata, aes(wingspan, wind_speed, fill = factor(insect))) +
  geom_hdr(xlim = c(-50, 250), ylim = c(40, 80)) +
  geom_point(shape = 21, size=5)
```


The following is playing around with images inserted into plots, i.e. the icons of butterflies and dragonflies. Also, the arrangement of several plots is shown here:

```{r}
# install first
library(rphylopic) # import the images of butterfly and dragonfly
library(patchwork) # for arranging the plots, like 'facet' used above

#import phylopic (go to phylopic.org -> browse image -> click on image to get url)
drfly <- image_data("2894776f-a2cf-4475-b13d-6d8ea1607ea4", size = 128)[[1]]
bufly <- image_data("ef0f4ab5-9714-45dc-8760-57e9080f941e", size = 128)[[1]]

p1 <- ggplot(mydata, aes(x = wind_speed, y = wingspan)) + 
        geom_point() + 
        add_phylopic(img = drfly) + 
        labs(x = 'Wind Speed', y = 'Wing span [mm]', size = 15) +
        theme_light()

###
p2 <- ggplot(mydata, aes(x = wind_speed, y =wingspan)) + 
        geom_point(color = rgb(0,0,0,0)) + 
        theme_light()

sub_drag <- subset(mydata, insect == 'dragonfly')
sub_butt <- subset(mydata, insect == 'butterfly')

for (i in 1:nrow(sub_drag)) {
  p2 <- p2 + add_phylopic(drfly, 1, 
                          sub_drag$wind_speed[i], 
                          sub_drag$wingspan[i],10,'blue')}
for (j in 1:nrow(sub_butt)) {
  p2 <- p2 + add_phylopic(bufly, 1, 
                          sub_butt$wind_speed[j], 
                          sub_butt$wingspan[j],10,'red')}

###
p3 <- ggplot(mydata, aes(x = wingspan, y = factor(insect))) +
        geom_density_ridges(fill = "gray90") + 
        add_phylopic(img = bufly, alpha=1, 
                     x = 50, y = 1.5, ysize = 20) +
        add_phylopic(img = drfly, alpha = 1, 
                     x = 80, y = 3, ysize = 25)  +
        labs(x = "Wing span [mm]", y = "Taxon") +
        theme_light()

### panel p3 on top, and below p1 and p2
p3 / (p1 + p2) + plot_annotation(tag_levels = "A", tag_suffix = ")")
```


Happy with the plot? Then save it:

```{r, eval=-5}
myridgeplot <- ggplot(mydata, aes(x = wingspan, y = factor(insect))) +
               geom_density_ridges(fill = "gray90") +
               labs(x = "Wing span [mm]", y = "Taxon") +
               theme_light()

myfilename <- paste0(output_wd,"/ridges.pdf")

ggsave(myridgeplot, file = myfilename, width = 4, height = 4)

#- Hint:
#- also works without the plot object named explicitly 
#- because ggsave() always refers to last plot by default:
# ggsave(file = myfilename, width = 4, height = 4) 
```

And find more inspiration here: https://www.r-graph-gallery.com/

<br>


# <span class='exercise'>Exercise 1</span>

1. Please load and inspect the following data set on wild boar observations in Berlin: `data_wb_melden_en.csv`. 
To load the data try both R functions, `read.csv()` and `read.table()`.<br>
You will find the data to download in the 'data' folder of the repository, i.e.:
<br>
data &rarr; data_berlin &rarr; animal_data
<br>


2. Use the functions `head()`, `names()`, `levels()`, `str()`, `table()` (hint: choose a column), 
`hist()` (hint: choose a column), `summary()` and `plot()` to inspect the data.<br><br>

3. Plot the number of piglets (`n_piglets`) per year.<br><br>

4. Now visualize only observations with more than four piglets and plot them over time (`date`).<br><br>

5. Create a column for the ratio of piglets vs the group size.<br>Afterwards visualize 
the number of piglets vs the year as a scatter plot and use a threshold of greater than 
0.5 to colour the points.<br><br>

6. Create a bar plot for the weather column and give each bar a color.<br>Save 
this bar plot with a header and column names as a pdf.<br><br>
<br>

Now have a look at the [base R cheatsheet](https://iqss.github.io/dss-workshops/R/Rintro/base-r-cheat-sheet.pdf) and check how much of it you understand.
<br>
<br>
<br>

# Advanced - Programming with R (shortly) 

This is very helpful for understanding your own data (i.e. simulate data where
you know exactly what happens and where you know what should come out) or
when you have repeated operations to do.
<br>

**@TUBerlin-Students, skip this part. You don't need to go through 
the following without prior lectures in statistics**
<br>

## Simulate your own data

R has a lot of distribution functions to simulate data:  
https://stat.ethz.ch/R-manual/R-devel/library/stats/html/Distributions.html
<br>
In the following, I am simulating a data set with an increasing trend. Think of
climate change, i.e.  increasing temperature (y-axis; trend_data) over 
time (x-axis; seq_data). That is, there is a functional relationship between time
and temperature with a **constant** (a *slope*) increase of 0.1 °C with every 
time step, i.e., the relationship is *linear*. Let's say the mean temperature 
before measuring was 5 °C, i.e. in our case at time step 0. 
Or, in other words, where the trend-line is crossing the y-axis. Let's call 
this *intercept*. Then, we can formulate the relationship 
<br>

trend_data = 5 + (0.1 * seq_data)        (eq. 1)
<br> 

or 
<br>

y = intercept + (slope * x)
<br>

However, real data often is not so exact, a lot of intrinsic and extrinsic
effects will influence the measurement. I therefore add a normally distributed
error term with mean zero and some variance (argument sd; norm_data) to the trend_data:

```{r, tidy=TRUE}
seq_data  <- seq(from = 1, to = 100, by = 1)     # create the x-axis, i.e. 100 time steps
norm_data <- rnorm(n = 100, mean = 0, sd = 1.96) # create normally distributed data (noise) around mean

#simulate trend = y-axis: intercept  + (slope * variable) +  error 
trend_data <-  5  + (0.1 * seq_data) + norm_data #e.g. temperature

par(mfrow = c(1,1))
plot(x = seq_data, y = trend_data, pch = 15, col = 'grey', ylim = c(0,20)) 
lines(x = trend_data, pch = 17, col = 'blue') 
abline(v=0,lty = 'dotted',col = 'grey33')
abline(a = 5, b = 0.1, col = 'red', lwd=0.5)
```

### Just for fun: some stats....

Very often, we only have the data points and want to estimate intercept and slope.
We do this with a so-called 'linear regression model'. Let's run and compare it
to the 'real' relationship that we have just simulated:
```{r}
my.lm <- lm(formula = trend_data ~ seq_data)
summary(object = my.lm) 
```
Surprise.... the intercept is ~ 5, slope ~ 0.1, residual error ~ 1.96 (= 1 sd). Now let's check
how well this represents the 'reality':

```{r}
par(mfrow=c(1,1))
plot(x = seq_data, y = trend_data, pch = 15, col = 'grey', ylim = c(0,20)) 
lines(x = trend_data, pch = 17, col = 'blue', lty=3) 
abline(a = 5, b = 0.1, col = 'red', lwd=2) # 'reality'

abline(my.lm, col = 'black',lwd=2) # fitted model
```
Pretty good! The two lines are almost identical. Now you can play around with
the slope value and sd-argument to see what is happening to your 'prediction'.
Or you can change the distribution function. 


## The *for* loop

saves a lot of time to automate operations, i.e. if you need to do the same 
operation on 1000 data sets.

```{r, eval=1}
#- for repetitive operations
#- *i* is used as counter variable that is incremented
for(i in 1:4)
{ #begin
  print(x = i)
  if (i == 4) print (x = 'end of lop')
} # end
?'for'
#other useful control flow constructs are: *while*, *repeat*, *if*
```

## Writing your own function

For repetitive actions and often used operations. <br>
@TUBerlin-Students , skip this part. You don't need to go through 
the following without prior lectures in statistics.
<br>

The basic syntax is: 
<br> 
function(*argument*){1 + 1 - *argument*}  
<br>
The function needs an argument, like e.g. a vector with numbers in the case 
of the function `mean()`. In the {} some operations are done with the argument.
<br>
Below, I set up two functions, `f_logit()` and `f_probit()`. Note the similarity of `f_logit()`
with our linear model above! `f_probit()` is a non-linear relationship; inside this
function, I call to another function, `exp()`, which needs the argument x. 
As example, imagine that I want to know the probability of presence of a rare species 
depending on the amount of forest in its surroundings. This relationship is given 
by `f_logit()`, and the `f_probit()` function transforms the values of the linear relationship
of `f_logit()` into a probability between 0 and 1.

```{r}
f_logit <- function(var1) {-8.13 + (12.15 * var1)}   # linear model
f_prob  <- function(var2) {1/ (1 + exp(x = -var2))} # inverse logit

# perc_for = e.g. percentage of forest in a sampling plot/ area between 0 and 1 (=100%)
perc_for <- seq(from = 0, to = 1 ,by = 0.05)

the_logit  <- f_logit(var1 =  perc_for)
pres_prob  <- f_prob(var2 = the_logit) # here values of f_logit() are inserted into f_prob() 

#pres_prob
plot(x = perc_for,y = pres_prob, type = 'l', 
     xlab = 'percentage of forest', ylab = 'prob of presence')
```


### Logistic regression and inverse logit

Similar to example above with the linear regression, we first create our
'real' distribution from which we sample:

```{r, tidy=TRUE}
# define functions at the beginning of a script:
f_logit <- function(var1, intcpt, slp) {intcpt + (slp * var1)}
f_prob  <- function(var2) {1 / (1 + exp(x = -var2))} # = inverse logit

# simulate trend, i.e. the 'real' relationship:
seq_data  <- seq(from = 0, to = 1, by=0.01) # e.g. forest percentage
trend_data <- pbinom(q = 1:length(seq_data), size = length(seq_data), prob = 0.6)
plot(x = seq_data, y = trend_data, pch = 15)
```

Now we have to convert the trend_data (which is our 'true' probability
of finding a species) into 0 or 1 (a Bernoulli trial) to simulate a sampling
process under field conditions, where we either find the species (1; presence) 
or not (0; absence) depending on the underlying forest percentage (seq_data).
The black lines stand for our field sampling:

```{r}
# install.packages("purrr") # in case the package is not installed
set.seed(500) # ignore this line
trend_data_binom <- purrr::rbernoulli(length(seq_data),trend_data)
plot(x = seq_data, y = trend_data, pch = 15, col = 'grey') # 'reality'
points(x = seq_data, y = trend_data_binom, pch = '|')      # our samples
```

On a side-note. Set the namespace, i.e. the package where the function is called from, with ` :: ` .This can be helpful if several packages use the same function name, but the function does something different in the packages, e.g. the plot() function, which is also used by many spatial R packages ! This sometimes leads to errors you are trying to solve for hours.
```{r}
#- examples 
# purrr::rbernoulli(length(seq_data),trend_data)
# base::plot(x = seq_data, y = trend_data, pch = 15, col = 'grey')
```



We now fit a logistic regression model with binomial error structure to
analyse our data:

```{r}
my.glm <- glm(formula = trend_data_binom ~ seq_data, family = 'binomial', na.action = na.omit)
summary(my.glm)

# store the output; access my.lm object via: 
#str(my.lm)
myintercept <- my.glm$coefficients[[1]]
myslope     <- my.glm$coefficients[[2]]

# predict it for a certain range of variable values (seq_data)...
mylogit   <- f_logit(var1 = seq_data, intcpt = myintercept, slp = myslope)
pres_prob <- f_prob(var2 = mylogit)

# strictly linear relationship on the logit scale:
plot(x = seq_data, y = mylogit, type = 'l', lwd = 2)
```

```{r}
# on the response / inverse logit scale:
plot(x = seq_data, y = pres_prob, type = 'l', lwd = 2)
```

Let's compare the 'true' simulated distribution, our field sampling
and the fitted model:

```{r}
plot(x = seq_data, y = pres_prob, type = 'l', lwd = 2) # fitted model
lines(x = seq_data, y = trend_data, pch = 15, col = 'grey') # 'true' distribution
points(x = seq_data, y = trend_data_binom, pch = '|') # field sampling based on 'true' distribution
```

...or predict it only for a single value:

```{r}
myvalue <- 0.5 # 50% forest cover
mylogit_s   <- f_logit(var1 = myvalue, intcpt = myintercept, slp = myslope)
(pres_prob_s <- f_prob(var2 = mylogit_s))

plot(x = seq_data, y = pres_prob, type = 'l', lwd = 2) # fitted model
abline(v = myvalue, lty = 2, lwd = 0.1)
abline(h = pres_prob_s, lty = 2, lwd = 0.1)
```

The probability of finding the species when there is 50% of forest in the area
is about `r round(pres_prob_s * 100,digits=0)`%.

<br>

***

<details><summary>Session Info</summary>

```{r sessionInfo}
Sys.time()
sessionInfo()
```

</details>


# END
